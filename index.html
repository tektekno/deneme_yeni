<!DOCTYPE html>
<html lang="tr">
  <head>
    <!-- Google tag (gtag.js) -->
    <script
      async
      src="https://www.googletagmanager.com/gtag/js?id=G-4Y5K6S0S87"
    ></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "G-4Y5K6S0S87");
    </script>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes"
    />

    <title>Duraklara Göre Sıralama</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Kode+Mono:wght@400..700&family=Madimi+One&family=Inter:wght@400;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      /* Genel ayarlar */
      body {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        height: 100vh;
        width: 100vw;
        background-color: black;
        color: white;
        font-family: "Kode Mono", monospace;
        overflow: hidden;
      }

      /* --- YENİ: Terminal Penceresi Stilleri --- */
      #terminal-window {
        border-top: 2px solid #8b5151;
        border-left: 5px solid #8b5151;
        border-right: 5px solid #8b5151;
        border-bottom: 5px solid #8b5151;
        border-radius: 8px;
        background-color: #0d0d0d;
        box-shadow: 0 0 20px rgba(0, 255, 65, 0.2);
        width: 99.2vw; /* Tam genişlik */
        height: 99.9vh; /* Tam yükseklik */
        display: flex;
        flex-direction: column;
        position: relative; /* YENİ: İçindeki absolute konumlandırılmış elementler için referans noktası olur. */
        overflow: hidden;
      }

      #title-bar {
        background-color: #8b5151;
        padding: 5px 10px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        border-bottom: 1px solid #555;
        user-select: none;
      }

      #title-bar .title {
        color: #ddd;
        font-weight: bold;
      }

      #title-bar .buttons span {
        display: inline-block;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        margin-left: 8px;
      }

      /* YENİ: Tam Ekran Butonu */
      #fullscreen-btn {
        color: #00ff41; /* YENİ: Rengi belirgin yeşil yapıldı */
        cursor: pointer;
        font-size: 24px; /* YENİ: Boyutu büyütüldü */
        padding: 0 10px; /* YENİ: Tıklama alanı genişletildi */
        user-select: none;
        text-shadow: 0 0 3px #00ff41; /* YENİ: Hafif parlama eklendi */
        transition: color 0.2s, text-shadow 0.2s; /* YENİ: Geçiş efekti eklendi */
      }

      #fullscreen-btn:hover {
        color: #8aff8a; /* YENİ: Üzerine gelince daha parlak yeşil */
        text-shadow: 0 0 8px #00ff41; /* YENİ: Parlama artırıldı */
      }
      /* --- Bitiş: Terminal Penceresi Stilleri --- */

      /* Tüm içeriği kapsayan container */
      .content {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center; /* Tüm içeriği dikeyde ortala */
        width: 100%;
        height: 100%;
      }

      #main-container {
        display: flex;
        flex-direction: column;
        width: 100%;
        flex-grow: 1; /* Terminal penceresinde kalan boşluğu doldurması için */
        overflow-y: auto; /* Gerektiğinde kaydırma çubuğu */
        padding: 0 2vw 5vh 2vw; /* YENİ: Alttan %5'lik boşluk eklendi */
        box-sizing: border-box; /* Padding'in genişliğe dahil edilmesini sağla */
      }

      /* Güncelleme yazısı ve yükleme simgesi için container */
      .updatetime-container {
        text-align: center;
        font-size: 1.2rem;
        padding-top: 1vh; /* Üstten küçük bir boşluk */
      }

      /* Yükleme Simgesi */
      .loader {
        border: 4px solid #f3f3f3; /* Açık gri */
        border-top: 4px solid #3498db; /* Mavi */
        border-radius: 50%;
        width: 30px;
        height: 30px;
        animation: spin 2s linear infinite;
        margin: 0 auto;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* Durakları içeren container */
      .container {
        display: flex;
        flex-wrap: nowrap;
        width: 100%;
        justify-content: center;
        margin-top: 2vh; /* Bilgi tablosu ile araya boşluk ekler */
        margin-bottom: 2vh; /* YENİ: Komut satırı ile araya boşluk ekler */
      }

      /* Durak kutuları */
      .durak {
        padding: 1vh 2vw;
        text-align: center;
        background-color: #1a1a1a; /* Kutuları arka plandan ayırmak için */
        color: white;
        overflow: hidden; /* Şeritin köşelerden taşan kısımlarını gizle */
        line-height: 1.2;
        border: 2px dashed #888; /* Kesikli çizgi çerçeve */
        transition: border-color 0.5s ease;
        position: relative; /* Şerit için zorunlu */
      }

      .durak {
        width: var(
          --durak-width,
          80vw
        ); /* JS'den gelen veya varsayılan değer */
        font-size: var(
          --durak-font-size,
          4vw
        ); /* JS'den gelen veya varsayılan değer */
      }

      /* Dinamik renk sınıfları */
      .durak.hizli {
        border-color: #00ff41;
        box-shadow: 0 0 5px #00ff41;
        text-shadow: 0 0 2px #00ff41;
      }

      .durak.orta {
        border-color: #ffc800;
        box-shadow: 0 0 5px #ffc800;
        text-shadow: 0 0 2px #ffc800;
      }

      .durak.yavas {
        border-color: #ff0000;
        box-shadow: 0 0 5px #ff0000;
        text-shadow: 0 0 2px #ff0000;
      }

      /* ------------------------------------------- */
      /* --- DİYAGONAL ŞERİT STİLLERİ BAŞLANGIÇ --- */
      /* --- YENİ GÜNCELLEME: DAHA AŞAĞI KONUMLANDIRMA VE KÜÇÜK YAZI BOYUTU --- */
      /* ------------------------------------------- */

      .durak::after {
        position: absolute;
        font-family: "Madimi One", sans-serif; /* Şeridi daha çarpıcı göstermek için font */
        color: white;

        /* YAZI ORTALAMASI */
        display: flex;
        justify-content: center; /* Yatayda ortala */
        align-items: center; /* Dikeyde ortala */

        /* Diyagonal şerit ayarları */
        width: 160%;
        top: 1.5vw; /* YENİ: Şeridin dikey konumunu yukarı çekti. */
        left: -75%; /* YENİ: Şeridin yatay konumunu sola çekti. */
        padding: 0.5vw 0;
        font-size: clamp(
          9px,
          1.6vw,
          16px
        ); /* <--- YENİ GÜNCELLEME: Genel font boyutu küçültüldü. */
        font-weight: 700;
        line-height: 1.2;
        transform: rotate(-45deg); /* Diyagonal eğim (SOL ÜSTTEN SAĞ ALTA) */
        z-index: 10;
        box-shadow: 0 0 1vw rgba(0, 0, 0, 0.5);
        text-shadow: 1px 1px 2px black;
        pointer-events: none;
      }

      /* En Hızlı Şeridi */
      .durak.hizli::after {
        content: "HIZLI";
        background-color: #00cc00; /* Parlak yeşil şerit */
      }

      /* Orta Hızlı Şeridi */
      .durak.orta::after {
        content: "ORTA";
        background-color: #ffcc00; /* Parlak sarı şerit */
      }

      /* En Yavaş Şeridi */
      .durak.yavas::after {
        content: "YAVAŞ";
        background-color: #ff3333; /* Parlak kırmızı şerit */
      }

      /* Küçük ekranlar (Dikey mobil) için şerit ayarı optimizasyonu */
      @media (max-width: 600px) {
        .durak::after {
          top: 20px; /* <--- YENİ GÜNCELLEME: Mobilde daha da aşağı (içeri) indirildi. */
          left: -70%;
          font-size: 13px; /* <--- YENİ GÜNCELLEME: Mobildeki font boyutu küçültüldü. */
        }
      }
      /* ------------------------------------------- */
      /* --- DİYAGONAL ŞERİT STİLLERİ BİTİŞ --- */
      /* ------------------------------------------- */

      /* Bilgi Tablosu Stilleri */
      #info-table {
        width: var(--durak-width, 85vw); /* Genişliği duraklarla aynı yapar */
        max-width: 96%; /* Ekranın kenarlarına yapışmasını önle */
        margin: 0 auto;
        border-collapse: collapse;
        font-size: clamp(
          10px,
          1.8vw,
          16px
        ); /* YENİ: Akışkan font boyutu (yatay için küçültüldü) */
        line-height: 1.4;
        border: 2px dashed #888; /* Kesikli çizgi çerçeve */
        box-shadow: 0 0 5px #888;
      }

      /* Satır Renkleri */
      #info-table tr:nth-child(1) {
        color: #c8a2c8;
        text-shadow: 0 0 3px #c8a2c8;
      } /* Açık Mor */
      #info-table tr:nth-child(2) {
        color: #ffc085;
        text-shadow: 0 0 3px #ffc085;
      } /* Açık Turuncu */
      #info-table tr:nth-child(3) {
        color: #ff8c8c;
        text-shadow: 0 0 3px #ff8c8c;
      } /* Açık Kırmızı */
      #info-table tr:nth-child(4) {
        color: #87ceeb;
        text-shadow: 0 0 3px #87ceeb;
      } /* Açık Mavi */
      @media (min-aspect-ratio: 1.1) {
        #info-table {
          width: 100%;
          max-width: 800px;
        }
      }

      #info-table .info-key {
        text-align: left;
        padding-right: 1em;
        white-space: nowrap;
        font-weight: bold;
      }

      #info-table .info-value {
        text-align: left;
        font-weight: bold;
      }

      /* Araç listesi için tablo stili */
      .vehicle-table {
        width: 100%;
        border-collapse: collapse; /* Kenarlıkları birleştir */
        margin-top: 0.5rem;
        font-size: inherit; /* Yazı tipi boyutunu parent elementten (durak) al */
      }

      .vehicle-table td {
        white-space: nowrap; /* Metnin satır atlamasını engelle */
        overflow: hidden; /* Taşmayı gizle */
        text-overflow: ellipsis; /* Taşma durumunda üç nokta göster */
        padding: 0 0.2vw;
      }

      .vehicle-table .right-align {
        text-align: right;
      }

      /* Ayırıcı Çizgi Stilleri */
      .separator-line {
        border: none;
        border-top: 1px dashed #555; /* Dijital ayırıcı çizgi */
        width: 100%;
        margin: 0.5rem 0;
      }

      .sub-separator-line {
        border: none;
        border-top: 1px dashed #444; /* Daha soluk alt ayırıcı */
        width: 100%;
        margin: 0.3rem 0;
      }

      /* Debug Butonları için Stiller */
      #debug-controls {
        position: fixed;
        bottom: 10px;
        right: 10px;
        background-color: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 8px;
        z-index: 1001;
        display: flex;
        flex-direction: column;
        gap: 8px;
        font-size: 0.9rem;
      }
      #debug-controls div {
        display: flex;
        align-items: center;
        gap: 5px;
      }
      #debug-controls button {
        width: 25px;
        height: 25px;
        font-weight: bold;
        cursor: pointer;
      }

      .metal-effect {
        font-weight: bold;
        color: #9e9e9e; /* YENİ: Daha koyu ve net gri */
        text-shadow: none !important; /* YENİ: Diğer satır stillerinden gelen gölgeyi sıfırlar */
        background: linear-gradient(
          90deg,
          #9e9e9e 48%,
          #ffffff 50%,
          #9e9e9e 52%
        );
        background-size: 300% 100%;
        background-position: 150% 0;
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        animation: metal-shine 3s linear infinite;
        animation: metal-shine 5s linear infinite;
        filter: drop-shadow(0 0 2px rgba(255, 255, 255, 0.3));
      }

      @keyframes metal-shine {
        0% {
          background-position: 150% 0; /* Başlangıç pozisyonu (sağda) */
        }
        100% {
          background-position: -150% 0; /* Bitiş pozisyonu (solda) */
        }
      }

      /* Ses kontrol ikonu */
      .speaker-icon {
        position: absolute;
        top: 1vh;
        right: 2vw;
        font-size: clamp(14px, 3vw, 24px);
        cursor: pointer;
        user-select: none; /* İkonun seçilmesini engelle */
      }

      /* Intro Ekranı */
      #intro-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: #000;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        cursor: default; /* İmleci normal yap */
        transition: opacity 0.5s ease-out;
      }
      .intro-content {
        text-align: center;
        color: white;
      }
      .intro-content h1 {
        font-size: clamp(24px, 8vw, 48px);
        margin-bottom: 10px;
      }
      .intro-button {
        /* Matrix stili */
        margin-top: 30px;
        padding: 12px 28px;
        font-size: clamp(16px, 4vw, 22px);
        font-family: "Kode Mono", monospace;
        color: #00ff41;
        background-color: transparent;
        border: 2px solid #00ff41; /* Köşeli buton */
        cursor: pointer;
        text-shadow: 0 0 5px #00ff41, 0 0 10px #00ff41;
        box-shadow: 0 0 5px #00ff41, inset 0 0 5px #00ff41;
        transition: text-shadow 0.3s, box-shadow 0.3s;
      }
      .intro-button:hover {
        /* Üzerine gelince parlamayı artır */
        text-shadow: 0 0 10px #00ff41, 0 0 20px #00ff41;
        box-shadow: 0 0 10px #00ff41, inset 0 0 10px #00ff41;
      }

      #matrix-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        opacity: 1; /* Düşük opaklık */
        z-index: 0; /* İçeriğin arkasında kalması için */
      }

      /* Yanıp Sönen İmleç Stili */
      #global-cursor {
        position: absolute;
        width: 8px;
        height: 1.2em; /* Satır yüksekliğine benzer */
        background-color: #00ff41;
        animation: blink 1.2s step-end infinite;
        z-index: 1000;
        display: none; /* Başlangıçta gizli */
        pointer-events: none; /* İmlecin tıklama olaylarını engellememesi için */
        transform: translateY(-10%);
        /* Akıcı JS kontrolü için CSS transition kaldırıldı */
      }

      /* YENİ: PWD içindeki metin imleci */
      .blinking-cursor {
        color: #00ff41;
        animation: blink 1.2s step-end infinite;
      }

      @keyframes blink {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0;
        }
      }

      /* --- YENİ: Yatay Mod Düzeni --- */
      @media (orientation: landscape) {
        #main-container {
          overflow-y: hidden; /* Yatayda kaydırma çubuğunu gizle */
        }
        #duraklar-container {
          flex-direction: row;
          align-items: stretch; /* Çocukların (durakların) yüksekliğini eşitler */
          flex-grow: 0.9; /* YENİ: Altta komut satırına yer açmak için biraz küçültüldü */
          gap: 1vw;
        }
        .durak {
          flex: 1; /* Eşit genişlikte yer kapla */
        }
      }

      /* --- YENİ: Kayan Trafik Bandı Stilleri --- */
      #traffic-banner-container {
        width: 100%;
        overflow: hidden;
        background-color: #111;
        margin: 2vh 0;
        white-space: nowrap;
        box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.5);
        border-top: 1px solid #444;
        border-bottom: 1px solid #444;
      }

      #traffic-banner-content {
        display: inline-block;
        padding-left: 100%; /* Animasyonun ekran dışından başlamasını sağlar */
        animation: scroll-traffic 45s linear infinite;
      }

      .traffic-item {
        display: inline-block;
        padding: 4px 12px;
        font-size: clamp(12px, 1.6vw, 16px);
      }

      .traffic-item:nth-child(odd) {
        background-color: hsl(0, 0%, 46%);
      }
      .traffic-item:nth-child(even) {
        background-color: #fff;
        color: #000; /* Beyaz arka planda siyah yazı */
      }

      @keyframes scroll-traffic {
        from {
          transform: translateX(0%);
        }
        to {
          transform: translateX(-100%);
        }
      }
    </style>
    <!-- Firebase SDK'ları -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>

    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
  </head>
  <body>
    <div id="intro-overlay">
      <canvas id="matrix-canvas"></canvas>
      <div class="intro-content" style="position: relative; z-index: 1">
        <h1>Küçükpark Taksi</h1>
        <h2>Durak Takip Uygulaması</h2>
        <button class="intro-button">Giriş Yapmak İçin Tıkla</button>
      </div>
    </div>
    <div id="debug-controls" style="display: none">
      <div>
        <span>Merkez:</span>
        <button id="add-merkez">+</button>
        <button id="add-closed-merkez">K+</button>
        <button id="remove-merkez">-</button>
      </div>
      <div>
        <span>Metro:</span>
        <button id="add-metro">+</button>
        <button id="add-closed-metro">K+</button>
        <button id="remove-metro">-</button>
      </div>
      <div>
        <span>Süvari:</span>
        <button id="add-suvari">+</button>
        <button id="add-closed-suvari">K+</button>
        <button id="remove-suvari">-</button>
      </div>
    </div>
    <!-- YENİ: Terminal Penceresi Çerçevesi -->
    <div class="content" style="display: none">
      <div id="terminal-window">
        <div id="title-bar">
          <div class="buttons">
            <span style="background: #ff5f57"></span>
            <span style="background: #ffbd2e"></span>
            <span style="background: #27c93f"></span>
          </div>
          <div class="title">kucukpark@taksi: ~</div>
          <!-- YENİ: Tam Ekran Butonu -->
          <div id="fullscreen-btn">⛶</div>
        </div>
        <div
          id="debug-warning"
          style="
            color: yellow;
            font-weight: bold;
            display: none;
            margin-bottom: 1rem;
            text-align: center;
          "
        >
          DİKKAT: DEBUG MODU AKTİF
        </div>
        <div id="main-container">
          <div class="updatetime-container">
            <!-- Yükleniyor simgesi -->
            <div id="loader" class="loader"></div>
            <!-- Yeni Bilgi Tablosu -->
            <table id="info-table" style="display: none">
              <tbody>
                <tr>
                  <td class="info-key">Son Güncelleme:</td>
                  <td id="info-updatetime" class="info-value"></td>
                </tr>
                <tr>
                  <td class="info-key">Araç Durumları:</td>
                  <td id="info-gps" class="info-value"></td>
                </tr>
                <tr>
                  <td class="info-key">Duyuru:</td>
                  <td id="info-closed-vehicle" class="info-value"></td>
                </tr>
                <tr>
                  <td class="info-key">Hava Durumu:</td>
                  <td id="info-weather" class="info-value"></td>
                </tr>
              </tbody>
            </table>
          </div>
          <!-- YENİ: Kayan trafik bandı için kapsayıcı -->
          <div id="traffic-banner-container" style="display: none;"><div id="traffic-banner-content"></div></div>
          <div id="duraklar-container" class="container"></div>
        </div>
      </div>
    </div>
    <div id="global-cursor"></div>
    <script>
      // --- Cihaz Engelleme Kontrolü ---
      // Bu fonksiyon, sayfanın geri kalanı çalışmadan önce çağrılır.
      (function () {
        // Engellenecek cihaz modellerini bu diziye ekleyebilirsiniz.
        const blockedModels = [];
        const userAgent = navigator.userAgent;

        // User agent'ın engellenen modellerden herhangi birini içerip içermediğini kontrol et
        const isBlocked = blockedModels.some((model) =>
          userAgent.includes(model)
        );

        if (isBlocked) {
          const blockedModelFound = blockedModels.find((model) =>
            userAgent.includes(model)
          );
          // Sayfa içeriğini temizle ve uyarı mesajı göster
          document.documentElement.innerHTML = `
            <head><title>Desteklenmiyor</title><meta name="viewport" content="width=device-width, initial-scale=1.0"></head>
            <body style="background-color: black; color: white; display: flex; align-items: center; justify-content: center; height: 100vh; margin: 0; font-family: 'Kode Mono', monospace; text-align: center; padding: 20px;">
            </body>`;
          throw new Error("Desteklenmeyen cihaz modeli: " + blockedModelFound); // Script'in geri kalanının çalışmasını engelle
        }
      })();

      // Firebase yapılandırma bilgileri
      const firebaseConfig = {
        apiKey: "AIzaSyCTTDvLsIY3ZS8zNP77lxLG0SdoOke2vLk",
        authDomain: "kptakip.firebaseapp.com",
        databaseURL:
          "https://kptakip-default-rtdb.europe-west1.firebasedatabase.app",
        projectId: "kptakip",
        storageBucket: "kptakip.firebasestorage.app",
        messagingSenderId: "401633293269",
        appId: "1:401633293269:web:8386edc126aafe1929435c",
      };
      // Firebase uygulamasını başlat
      firebase.initializeApp(firebaseConfig);
      const database = firebase.database();
      const ref = database.ref("taksi_verileri");
      // Elemanları seç
      let mainContainer = document.getElementById("main-container");
      let duraklarContainer = document.getElementById("duraklar-container");
      let loaderElement = document.getElementById("loader");
      let infoTable = document.getElementById("info-table");
      let infoUpdateTime = document.getElementById("info-updatetime");
      let infoGps = document.getElementById("info-gps");
      let infoClosedVehicle = document.getElementById("info-closed-vehicle");
      let infoWeather = document.getElementById("info-weather");
      const globalCursor = document.getElementById("global-cursor");
      const terminalContent = document.querySelector(".content");

      // YENİ: Durakları belirli bir sırada tutmak için sabit
      const orderedDuraks = ["merkez", "metro", "suvari"];

      // YENİ: Giriş animasyonunu kontrol etmek için sabit
      const ENABLE_BOOT_SEQUENCE = true;

      const HALT_AFTER_BOOT = false;

      // En son yüklenen veriyi tutmak için değişken
      let latestData = null;
      // Önceki araç sayılarını tutmak için değişken
      let previousVehicleCounts = {};
      // Durakların ses durumunu tutmak için değişken
      let stationMuteStatus = {
        merkez: false, // false = ses açık, true = ses kapalı
        metro: false,
        suvari: false,
      };
      // İlk kullanıcı etkileşimini takip etmek için bayrak
      let firstInteraction = false;
      // Sesleri sırayla çalmak için bir kuyruk ve durum değişkeni
      let audioQueue = [];
      let isPlayingAudio = false;
      // Web Audio API için değişkenler
      let audioContext;
      // Son işlem yapılan aracı ve durağı takip etmek için
      let lastModifiedVehicle = { durakKey: null, plate: null, action: null };
      // Önceki tam veriyi tutmak için
      let previousData = null;
      let audioBuffers = {};
      // YENİ: Boş durak anonsları için zamanlayıcıları ve durumları tutacak nesne
      let emptyStationTimers = {
        merkez: { timerId: null, lastAnnounced: 0 },
        metro: { timerId: null, lastAnnounced: 0 },
        suvari: { timerId: null, lastAnnounced: 0 },
      };
      let isPreloading = false;

      /**
       * YENİ: Boş duraklar için sesli anonsları yönetir.
       */
      function manageEmptyStationAnnouncements() {
        if (!latestData || !firstInteraction) return;

        const now = Date.now();
        const EMPTY_STATION_INITIAL_DELAY = 3 * 60 * 1000; // 3 dakika
        const EMPTY_STATION_REPEAT_DELAY = 2 * 60 * 1000; // 2 dakika

        orderedDuraks.forEach((key) => {
          const aracSayisi = latestData.duraklar[key].liste
            ? latestData.duraklar[key].liste.filter((arac) => !arac.is_closed)
                .length
            : 0;

          if (aracSayisi === 0) {
            // Durak boş
            if (
              emptyStationTimers[key].timerId === null && // Zamanlayıcı zaten çalışmıyorsa
              emptyStationTimers[key].lastAnnounced === 0 // Ve daha önce hiç anons yapılmadıysa
            ) {
              // Zamanlayıcıyı başlat (eğer daha önce hiç anons yapılmadıysa)
              const timerId = setTimeout(() => {
                // 3 dakika geçti, ilk anonsu yap
                const audioUrl = `https://raw.githubusercontent.com/tektekno/deneme_yeni/master/voices/${key}0.opus`;
                if (!stationMuteStatus[key]) {
                  audioQueue.push(audioUrl);
                  playAudioFromQueue();
                }
                emptyStationTimers[key].lastAnnounced = Date.now();
              }, EMPTY_STATION_INITIAL_DELAY);
              emptyStationTimers[key].timerId = timerId;
            } else if (
              emptyStationTimers[key].lastAnnounced > 0 &&
              now - emptyStationTimers[key].lastAnnounced >=
                EMPTY_STATION_REPEAT_DELAY
            ) {
              // Tekrarlama süresi doldu, tekrar anons yap
              const audioUrl = `https://raw.githubusercontent.com/tektekno/deneme_yeni/master/voices/${key}0.opus`;
              if (!stationMuteStatus[key]) {
                audioQueue.push(audioUrl);
                playAudioFromQueue();
              }
              emptyStationTimers[key].lastAnnounced = now;
            }
          } else {
            // Durak boş değil, zamanlayıcıyı ve durumu temizle
            clearTimeout(emptyStationTimers[key].timerId);
            emptyStationTimers[key].timerId = null;
            emptyStationTimers[key].lastAnnounced = 0;
            // YENİ: Durak artık boş değilse, bu durağa ait "boş" anonsunu ses kuyruğundan kaldır.
            // Bu, durağa araç girdikten sonra gecikmeli "boş" anonsunun çalınmasını engeller.
            const emptyAudioUrl = `https://raw.githubusercontent.com/tektekno/deneme_yeni/master/voices/${key}0.opus`;
            audioQueue = audioQueue.filter((url) => url !== emptyAudioUrl);
          }
        });
      }

      /**
       * Saniye cinsinden verilen süreyi "Xgn Ysa Zdk Psn" formatına dönüştürür.
       * @param {number} totalSeconds - Toplam saniye süresi.
       * @returns {string} Formatlanmış süre metni.
       */
      function formatDuration(totalSeconds) {
        if (totalSeconds < 0) {
          totalSeconds = 0;
        }

        const days = Math.floor(totalSeconds / (24 * 60 * 60));
        const hours = Math.floor((totalSeconds % (24 * 60 * 60)) / (60 * 60));
        const minutes = Math.floor((totalSeconds % (60 * 60)) / 60);
        const seconds = totalSeconds % 60;

        const parts = [];
        if (days > 0) {
          parts.push(`${days}gn`);
        }
        if (hours > 0) {
          parts.push(`${hours}sa`);
        }
        if (minutes > 0) {
          parts.push(`${minutes}dk`);
        }
        parts.push(`${seconds}sn`);

        return parts.join(" ");
      }

      /**
       * Zaman birimini formatlar. Eğer değer 0 ise ve forceDisplayZero true değilse boş string döndürür.
       * Tek haneli değerler için bir boşluk ekler ve sağa yaslar.
       * @param {number} value - Zaman biriminin değeri (gün, saat, dakika, saniye).
       * @param {string} unit - Zaman biriminin kısaltması (örn: 'gn', 'sa', 'dk', 'sn').
       * @param {boolean} [forceDisplayZero=false] - Değer 0 olsa bile gösterilmesini zorlar.
       * @param {string} [padChar='&nbsp;'] - Tek haneli değerler için kullanılacak dolgu karakteri.
       * @returns {string} Doldurulmuş ve hizalanmış metin veya boş string.
       */
      function padTimeDisplay(
        value,
        unit,
        forceDisplayZero = false,
        padChar = "&nbsp;"
      ) {
        if (value === 0 && !forceDisplayZero) {
          return "";
        }
        // Tek haneli değerler için bir boşluk ekle
        if (value < 10 && value >= 0) {
          return `${padChar}${value}${unit}`;
        }
        return `${value}${unit}`;
      }

      /**
       * YENİ: Trafik durumu verisini DİKEY olarak işler ve renkli HTML çıktısı üretir.
       * @param {object} trafficData - Firebase'den gelen trafik_durumu nesnesi.
       * @returns {string} HTML olarak formatlanmış dikey trafik durumu listesi.
       */
      function getTrafficStatusVertical(trafficData) {
        if (!trafficData) return "Veri yok";

        const statusMap = {
          AcikYol: { text: "Açık", color: "#00ff41" },
          HafifYogunYol: { text: "Hafif", color: "#ffc800" },
          YogunYol: { text: "Yoğun", color: "#ff0000" },
        };

        const nameMap = {
          ankara_cd_gidis: "Ankara Cd. Gidiş:",
          ankara_cd_donus: "Ankara Cd. Dönüş:",
          ankara_cd_yanyol_gidis: "Ankara Cd. Yanyol Gidiş:",
          ankara_cd_yanyol_donus: "Yan Yol Dönüş:",
          agacli_yol: "Ağaçlı Yol:",
          adliye_kavsagi_gidis: "Adliye Kavşağı Gidiş:",
          alsancak_liman_yolu: "Alsancak Liman Yolu:",
          alsancak_gar_onu_gidis: "Alsancak Gar Önü Gidiş:",
          alsancak_gar_onu_donus: "Alsancak Gar Önü Dönüş:",
          alsancak_kordon: "Alsancak Kordon:",
          forum_agacli_yol_gidis: "Forum Ağaçlı Yol Gidiş:",
          forum_agacli_yol_gelis: "Forum Ağaçlı Yol Geliş:",
          cesme_otobani_gidis: "Çeşme Otobanı Gidiş:",
          cigli_otobani_gidis: "Çiğli Otobanı Gidiş:",
        };

        // YENİ: Trafik bandı için HTML oluştur
        let html = "";
        const allKeys = Object.keys(trafficData);

        // İki kez yazdırarak kesintisiz bir döngü oluştur
        [...allKeys, ...allKeys].forEach((key) => {
          if (!trafficData.hasOwnProperty(key)) return;
          const status = trafficData[key];
          const displayName = nameMap[key] || key;
          const { text, color } = statusMap[status] || {
            text: status,
            color: "white",
          };
          // Beyaz arka planda yazı rengini ayarla
          const textColorStyle = `color: ${color}; text-shadow: 0 0 2px ${color};`;
          html += `<div class="traffic-item">${displayName} <span style="${textColorStyle}">${text}</span></div>`;
        });
        return html;
      }

      /**
       * Hava durumu kodunu okunabilir bir metne çevirir.
       * @param {number} code - Open-Meteo'dan gelen hava durumu kodu.
       * @returns {string} Hava durumu açıklaması.
       */
      function getWeatherDescription(code) {
        const descriptions = {
          0: "Açık",
          1: "Parçalı Bulutlu",
          2: "Parçalı Bulutlu",
          3: "Bulutlu",
          45: "Sisli",
          48: "Sisli",
          51: "Çiselemeli",
          53: "Çiselemeli",
          55: "Çiselemeli",
          56: "Dondurucu Çiseleme",
          57: "Dondurucu Çiseleme",
          61: "Yağmurlu",
          63: "Yağmurlu",
          65: "Şiddetli Yağmurlu",
          66: "Dondurucu Yağmur",
          67: "Dondurucu Yağmur",
          71: "Karlı",
          73: "Karlı",
          75: "Yoğun Karlı",
          77: "Kar Taneleri",
          80: "Sağanak Yağışlı",
          81: "Sağanak Yağışlı",
          82: "Şiddetli Sağanak",
          95: "Gök Gürültülü",
          96: "Hafif Dolu",
          85: "Kar Sağanağı",
          86: "Yoğun Kar Sağanağı",
          99: "Şiddetli Dolu",
        };
        return descriptions[code] || "Bilinmiyor";
      }

      /**
       * Bornova, İzmir için hava durumu verilerini çeker ve gösterir.
       */
      async function fetchWeather() {
        try {
          const response = await fetch(
            "https://api.open-meteo.com/v1/forecast?latitude=38.46&longitude=27.22&daily=weathercode&timezone=Europe/Istanbul"
          );
          const data = await response.json();

          const today = data.daily;

          // Yağmur, kar, dolu ve fırtına gibi araç yıkamaya uygun olmayan tüm kötü hava kodları
          const badWeatherCodes = [
            51, 53, 55, 61, 63, 65, 66, 67, 71, 73, 75, 77, 80, 81, 82, 85, 86,
            95, 96, 99,
          ];
          const tomorrowCode = today.weathercode[1];
          const weatherRow = infoWeather.parentElement; // <tr> elementini al

          if (badWeatherCodes.includes(tomorrowCode)) {
            infoWeather.textContent = "🌧️☂️Yakında yağış var, araç yıkanmaz."; // Renk CSS'den gelecek
            // Yağış varsa, satır rengini camgöbeği yap ama animasyon ekleme
            weatherRow.style.color = "#00ffff";
          } else {
            infoWeather.textContent = "Yakında yağış yok, araç yıkanır."; // Renk CSS'den gelecek
            // Yağış yoksa, satır rengini varsayılana döndür
            weatherRow.style.color = "";
          }
        } catch (error) {
          console.error("Hava durumu verisi alınamadı:", error);
          infoWeather.textContent = "Bilgi alınamadı.";
        }
      }

      /**
       * Tüm ses dosyalarını önceden yükler ve audioBuffers nesnesine kaydeder.
       */
      async function preloadAudioFiles() {
        if (isPreloading || Object.keys(audioBuffers).length > 33) return; // Zaten yükleniyorsa veya yüklendiyse çık
        isPreloading = true;
        console.log("Ses dosyaları ön yükleniyor...");

        const duraklar = ["merkez", "metro", "suvari"];
        const promises = [];

        for (const durak of duraklar) {
          for (let i = 0; i <= 10; i++) {
            const fileName = `${durak}${i}.opus`;
            const url = `https://raw.githubusercontent.com/tektekno/deneme_yeni/master/voices/${fileName}`;

            const promise = fetch(url)
              .then((response) => response.arrayBuffer())
              .then((arrayBuffer) => audioContext.decodeAudioData(arrayBuffer))
              .then((decodedData) => {
                audioBuffers[url] = decodedData;
              })
              .catch((err) => {
                // console.error(`${fileName} yüklenemedi:`, err);
              });
            promises.push(promise);
          }
        }

        await Promise.all(promises);
        isPreloading = false;
        console.log("Tüm ses dosyaları ön yüklendi.");
      }

      /**
       * Ses kuyruğundaki dosyaları sırayla çalar.
       */
      function playAudioFromQueue() {
        if (isPlayingAudio || audioQueue.length === 0 || !firstInteraction)
          return;

        isPlayingAudio = true;
        const urlToPlay = audioQueue.shift();
        const audioBuffer = audioBuffers[urlToPlay];

        if (!audioBuffer) {
          console.error(`Ses buffer'ı bulunamadı: ${urlToPlay}`);
          isPlayingAudio = false; // Hata durumunda durumu sıfırla
          // Hatalı olsa bile sıradakine geç
          setTimeout(playAudioFromQueue, 200);
          return;
        }

        const source = audioContext.createBufferSource();
        source.buffer = audioBuffer;
        source.connect(audioContext.destination);
        source.start(0);

        source.onended = () => {
          isPlayingAudio = false;
          // Sesler arasında küçük bir nefes payı bırakmak için kısa bir gecikme
          setTimeout(playAudioFromQueue, 200);
        };
      }

      /**
       * Bir satıra karakter karakter yazma efekti uygular.
       * @param {HTMLTableRowElement} row - Efektin uygulanacağı satır.
       * @param {string[]} cellContents - Hücrelere yazılacak içerikler.
       * @param {number} speed - Yazma hızı (ms).
       */
      function typewriterEffect(row, cellContents, speed = 80) {
        // innerHTML yerine textContent kullanarak &nbsp; gibi karakterlerin görünmesini engelle
        const textContents = cellContents.map((html) => {
          const tempDiv = document.createElement("div");
          tempDiv.innerHTML = html;
          return tempDiv.textContent || "";
        });
        const totalContent = textContents.join("");
        if (totalContent.length === 0) return;

        // Önce satırı boşalt ve imleci ekle
        const cells = row.querySelectorAll("td");
        let charIndex = 0;

        // --- YENİ İYİLEŞTİRME: Sütun kaymasını engelleme ---
        // Animasyon başlamadan önce hücrelere tam içeriği görünmez bir şekilde yükleyip
        // tarayıcının sütun genişliklerini hesaplamasını sağla, sonra temizle.
        cells.forEach((cell, i) => {
          cell.style.visibility = "hidden";
          cell.innerHTML = cellContents[i];
        });
        // Tarayıcının DOM'u güncellemesi için kısa bir gecikme
        setTimeout(() => {
          cells.forEach((cell) => {
            cell.style.visibility = "visible";
            cell.innerHTML = "";
          });
          type(); // Animasyonu başlat
        }, 0);

        function type() {
          if (charIndex < totalContent.length) {
            let currentLength = 0;
            for (let i = 0; i < textContents.length; i++) {
              const cellText = textContents[i];
              const remainingLengthInCell = charIndex - currentLength;

              if (remainingLengthInCell >= 0) {
                const currentCellText = cellText.substring(
                  0,
                  remainingLengthInCell + 1
                );
                cells[i].textContent = currentCellText;

                // İmleci sadece son karakterin yazıldığı hücrede güncelle
                if (charIndex < currentLength + cellText.length) {
                  // --- YENİ YÖNTEM: İmleç pozisyonunu Range ile al (Hizalama sorununu çözer) ---
                  const range = document.createRange();
                  // Hücrede metin düğümü varsa onu, yoksa hücrenin kendisini referans al.
                  const textNode = cells[i].firstChild || cells[i];
                  // Range'i metnin sonuna ayarla.
                  range.setStart(textNode, currentCellText.length);
                  range.collapse(true); // Range'i başlangıç noktasına daralt.

                  const rect = range.getBoundingClientRect();
                  globalCursor.style.top = `${rect.top + window.scrollY}px`;
                  globalCursor.style.left = `${rect.left + window.scrollX}px`;
                }
              }

              currentLength += cellText.length;
              if (charIndex < currentLength) break;
            }

            setTimeout(type, speed);
            charIndex++; // Önce zamanlayıcıyı kur, sonra indeksi artır
          } else {
            // Efekt bitince orijinal HTML'i geri yükle
            cellContents.forEach(
              (content, i) => (cells[i].innerHTML = content)
            );
            globalCursor.style.display = "none"; // YENİ: Animasyon bitince global imleci gizle.
            // YENİ: Hizalama sorununu kesin olarak çözmek için, animasyon bittikten sonra
            // tüm arayüzü en güncel veriyle yeniden çiz. Bu, tarayıcının tablo
            // düzenini sıfırlamasını ve doğru hizalamayı yapmasını sağlar.
            renderData(latestData);
          }
        }
      }

      /**
       * Bir satırdan karakter karakter silme efekti uygular.
       * @param {HTMLTableRowElement} row - Efektin uygulanacağı satır.
       * @param {Function} onComplete - Silme işlemi bittiğinde çağrılacak fonksiyon.
       * @param {number} speed - Silme hızı (ms).
       */
      function deleteEffect(row, onComplete, speed = 50) {
        const cells = Array.from(row.querySelectorAll("td"));
        const reversedCells = [...cells].reverse(); // Sondan başa doğru silmek için
        let currentCellIndex = 0;

        // Silinecek metin kalmadıysa bitir
        if (reversedCells.every((cell) => cell.textContent.length === 0)) {
          onComplete();
          return;
        }

        function deleteFromCell() {
          // Tüm hücreler boşaldıysa animasyonu bitir
          if (currentCellIndex >= reversedCells.length) {
            moveCursorToBottom();
            onComplete();
            return;
          }

          let cell = reversedCells[currentCellIndex];

          // Eğer mevcut hücre zaten boşsa, bir sonrakine geç
          while (cell && cell.textContent.length === 0) {
            currentCellIndex++;
            cell = reversedCells[currentCellIndex];
          }

          // Eğer hala geçerli bir hücre varsa, silme işlemine devam et
          if (cell) {
            cell.textContent = cell.textContent.slice(0, -1); // Son karakteri sil

            // YALNIZCA metin varsa imleci güncelle, aksi takdirde ışınlanma olur.
            if (cell.firstChild) {
              const range = document.createRange();
              range.setStart(cell.firstChild, cell.textContent.length);
              range.collapse(true);
              const rect = range.getBoundingClientRect();
              globalCursor.style.top = `${rect.top + window.scrollY}px`;
              globalCursor.style.left = `${rect.left + window.scrollX}px`;
            }
            setTimeout(deleteFromCell, speed);
          } else {
            // Silinecek başka hücre kalmadıysa animasyonu bitir.
            globalCursor.style.display = "none"; // Global imleci gizle.
            moveCursorToBottom(); // Ana imleci ve prompt'u göster.
            onComplete();
          }
        }
        deleteFromCell();
      }

      /**
       * İmleci hedef konuma satır satır, sütun sütun taşır.
       * @param {number} targetLeft - Hedef sol pozisyon.
       * @param {number} targetTop - Hedef üst pozisyon.
       * @param {Function} onComplete - Animasyon bittiğinde çalışacak fonksiyon.
       */
      function moveCursorStepByStep(targetLeft, targetTop, onComplete) {
        const cursorRect = globalCursor.getBoundingClientRect();
        let currentTop = cursorRect.top + window.scrollY;
        let currentLeft = cursorRect.left + window.scrollX;

        // 1px adım kullan
        const stepY = 20; // Dikey hızı artırmak için değeri yükselttim
        const stepX = 15; // Yatay hızı artırmak için değeri yükselttim

        function animate() {
          let moved = false;

          // Dikey hareket
          if (Math.abs(targetTop - currentTop) > 0.1) {
            const direction = Math.sign(targetTop - currentTop);
            currentTop += direction * stepY;
            // Hedefi geçme kontrolü
            if (
              direction > 0 ? currentTop > targetTop : currentTop < targetTop
            ) {
              currentTop = targetTop;
            }
            globalCursor.style.top = `${currentTop}px`;
            moved = true;
          }
          // Yatay hareket (dikey bittikten sonra)
          else if (Math.abs(targetLeft - currentLeft) > 0.1) {
            const direction = Math.sign(targetLeft - currentLeft);
            currentLeft += direction * stepX;
            // Hedefi geçme kontrolü
            if (
              direction > 0
                ? currentLeft > targetLeft
                : currentLeft < targetLeft
            ) {
              currentLeft = targetLeft;
            }
            globalCursor.style.left = `${currentLeft}px`;
            moved = true;
          }

          if (moved) requestAnimationFrame(animate);
          else if (onComplete) onComplete();
        }
        animate();
      }

      /**
       * İmleci hedef satıra animasyonla taşır.
       * @param {HTMLElement} targetRow - Hedef satır elementi.
       * @param {Function} onComplete - Animasyon bittiğinde çalışacak fonksiyon.
       */
      function animateCursorToRow(targetRow, onComplete) {
        const promptLine = document.getElementById("prompt-line");
        if (!globalCursor || !targetRow || !promptLine) {
          if (onComplete) onComplete();
          return;
        }

        promptLine.style.display = "none"; // YENİ: Animasyon başlarken komut satırını gizle.

        // YENİ: Animasyon başlarken ana imleci gizle, global imleci göster.
        document
          .getElementById("main-cursor")
          ?.style.setProperty("display", "none");
        globalCursor.style.display = "block";

        const targetRect = targetRow.getBoundingClientRect();
        const targetTop = targetRect.top + window.scrollY;
        const targetLeft = targetRect.left + window.scrollX;

        // YENİ: Animasyon bittiğinde komut satırını tekrar göster.
        const animationCompleteCallback = () => {
          promptLine.style.display = "block"; // Komut satırını göster.
          if (onComplete) onComplete();
        };
        moveCursorStepByStep(targetLeft, targetTop, animationCompleteCallback);
      }

      /**
       * Global imleci en alttaki durak kutusunun altına taşır.
       */
      function moveCursorToBottom() {
        // YENİ: Eğer başlangıç animasyonu hala çalışıyorsa (yani ilk veri henüz gelmediyse),
        // bu fonksiyonun kendi prompt'unu oluşturmasını engelle. Animasyon kendi prompt'unu yönetir.
        if (ENABLE_BOOT_SEQUENCE && !latestData) return;

        // YENİ: Prompt için bir element oluştur (eğer yoksa)
        let promptLine = document.getElementById("prompt-line");
        if (!promptLine) {
          promptLine = document.createElement("div");
          promptLine.id = "prompt-line";
          promptLine.innerHTML = `<span style="color: #00ff41;">kucukpark@taksi</span><span style="color: white;">:</span><span style="color: #5c99ff;">~</span><span style="color: white;">$&nbsp;</span><span id="main-cursor" class="blinking-cursor">█</span>`;
          const mainContainer = document.getElementById("main-container");
          if (mainContainer) mainContainer.appendChild(promptLine);
        }

        // YENİ: Prompt'u mutlak konumlandırmak yerine normal akışta bırak.
        promptLine.style.position = "static";
        promptLine.style.display = "block"; // Veya 'inline-block'
        mainContainer.appendChild(promptLine); // Her zaman sonda olduğundan emin ol
        mainContainer.scrollTop = mainContainer.scrollHeight; // En alta kaydır

        // İmleci prompt'un sonuna konumlandır
        const promptRect = promptLine.getBoundingClientRect();
        // YENİ: Artık global imleç burada konumlanmıyor, sadece ana imleç gösteriliyor.
        globalCursor.style.display = "none";
        document
          .getElementById("main-cursor")
          ?.style.setProperty("display", "inline");
      }

      function runBootSequence(onComplete) {
        const container = document.getElementById("main-container");
        container.innerHTML = ""; // Ana içeriği temizle

        // YENİ: Komut satırını ve imleci animasyon sırasında yönetmek için oluştur.
        const promptLine = document.createElement("div");
        promptLine.id = "prompt-line";

        // YENİ: Yatay ve dikey mod için farklı padding değerleri ayarla.
        const aspectRatio = window.innerWidth / window.innerHeight;
        // YENİ: Metinleri sola yaslamak için yatay padding kaldırıldı.
        const paddingStyle = "0 0.2vw";

        promptLine.style.padding =
          "0"; /* YENİ: Padding'i sıfırla, hizalama için span'e ekle */
        promptLine.style.whiteSpace = "pre";
        promptLine.innerHTML = `<span style="padding: 0 0.1vw; display: inline-block;"><span style="color: #00ff41;">kucukpark@taksi</span><span style="color: white;">:</span><span style="color: #5c99ff;">~</span><span style="color: white;">$&nbsp;</span><span id="main-cursor" class="blinking-cursor">█</span></span>`;
        container.appendChild(promptLine);

        const modules = [
          "core-services",
          "network-interfaces",
          "security-protocols",
          "audio-subsystem",
          "geolocation-api",
          "data-sync-manager",
          "ui-renderer",
          "voice-assistant-module",
          "realtime-listeners",
          "asset-preloader",
        ];

        let moduleIndex = 0;

        function loadNextModule() {
          if (moduleIndex < modules.length) {
            const moduleName = modules[moduleIndex];

            // YENİ: Yükleme metni ve progress bar için ayrı elementler oluştur.
            const textElement = document.createElement("div");
            textElement.style.padding = paddingStyle;
            textElement.style.whiteSpace = "pre";
            textElement.textContent = `Loading ${moduleName}...`;

            const barContainer = document.createElement("div");
            barContainer.style.padding = paddingStyle;
            barContainer.style.whiteSpace = "pre";

            // Elementleri komut satırının üstüne ekle.
            container.insertBefore(textElement, promptLine);
            container.insertBefore(barContainer, promptLine);

            let progress = 0;
            const totalAnimationTime = 300; // Her bar için toplam animasyon süresi (ms)

            // YENİ: Progress bar genişliğini, üstündeki metnin uzunluğuna göre ayarla.
            // Bu, ekran genişliğinden bağımsız, tutarlı bir görünüm sağlar.
            const progressBarWidth =
              textElement.textContent.length - "[] 100%".length;
            const stepDelay = totalAnimationTime / progressBarWidth;

            function updateProgress() {
              if (progress <= progressBarWidth) {
                const bar =
                  "[" +
                  "█".repeat(progress) +
                  "─".repeat(progressBarWidth - progress) +
                  "]"; // YENİ: Taşma sorununu çözmek için karakter değiştirildi.
                const percentage = Math.floor(
                  (progress / progressBarWidth) * 100
                );
                barContainer.textContent = `${bar} ${percentage}%`;

                container.scrollTop = container.scrollHeight;

                progress++;
                setTimeout(updateProgress, stepDelay);
              } else {
                // Yükleme tamamlandı, [OK] göster
                textElement.innerHTML += ` <span style="color: #00ff41;">[OK]</span>`;
                barContainer.remove(); // Progress bar'ı kaldır.
                moduleIndex++;
                setTimeout(loadNextModule, Math.random() * 150 + 50);
              }
            }
            updateProgress();
          } else {
            // Tüm modüller yüklendi
            const finalMsg = document.createElement("div");
            finalMsg.style.padding = paddingStyle;
            finalMsg.style.color = "#ffc800";
            finalMsg.textContent = "\nSystem ready. Welcome, operator.";
            container.insertBefore(finalMsg, promptLine); // YENİ: Mesajı komut satırının üzerine ekle.

            container.scrollTop = container.scrollHeight;
            if (!HALT_AFTER_BOOT) {
              setTimeout(onComplete, 700);
            }
          }
        }
        loadNextModule();
      }

      function renderData(data, options = { playSound: true }) {
        // En son veriyi global olarak sakla
        latestData = data;

        // Yükleme simgesini gizle ve güncelleme metinlerini göster
        loaderElement.style.display = "none";
        infoTable.style.display = "table";

        // Güncelleme zamanını ve GPS bilgi metnini ayarla
        infoUpdateTime.textContent = data.son_guncelleme;
        infoGps.textContent = "Tüm araçlardaki sorunlar düzeltildi."; // Metin zaten doğru, teyit edildi.
        infoClosedVehicle.textContent =
          "Kırmızı renkteki araçlar kapalıdır, sıraya dahil değildir.";

        // Hava durumu verisini sadece ana veri yüklendikten sonra çek ve göster
        fetchWeather();

        // Dinamik font büyüklüğü sınıfları için stilleri dinamik olarak ekle
        // "Araç Durumları" satırına metalik parlama efekti ekle
        infoGps.parentElement.classList.add("metal-effect");

        const contentDiv = document.querySelector(".content");
        const aspectRatio = window.innerWidth / window.innerHeight;

        // Durak bilgilerini işle
        // --- ANİMASYON İYİLEŞTİRMESİ ---
        // Silme animasyonunun bozulmaması için, eğer silme işlemi yapılmıyorsa veya zaten durak yoksa DOM'u temizle.
        // Silme işlemi sırasında DOM temizlenmeyecek, sadece ilgili satır animasyonla silinecek.
        duraklarContainer.innerHTML = "";
        const duraklar = data.duraklar;
        // YENİ: Trafik bandını render et
        renderTrafficBanner(data);

        const durak_names = {
          suvari: "Süvari",
          merkez: "Merkez",
          metro: "Metro",
        };

        // Ortalama kalkış sürelerini topla ve sırala
        const averageTimes = orderedDuraks
          .map((key) => ({
            key,
            time: duraklar[key].ortalama_kalkis,
          }))
          .sort((a, b) => a.time - b.time);

        // En hızlı, orta ve en yavaş durakları belirle
        const fastest = averageTimes[0].key;
        const middle = averageTimes[1].key;
        const slowest = averageTimes[2].key;

        // --- YENİ ORANTISAL YÜKSEKLİK HESAPLAMA MANTIĞI ---
        // 1. Tüm duraklardaki araç sayılarını al
        const vehicleCounts = {
          merkez: duraklar.merkez.liste ? duraklar.merkez.liste.length : 0,
          metro: duraklar.metro.liste ? duraklar.metro.liste.length : 0,
          suvari: duraklar.suvari.liste ? duraklar.suvari.liste.length : 0,
        };
        const totalVehicles =
          vehicleCounts.merkez + vehicleCounts.metro + vehicleCounts.suvari;

        // Değişiklik tespiti (Ekleme/Silme)
        if (previousData) {
          for (const key of orderedDuraks) {
            const prevList = previousData.duraklar[key].liste || [];
            const newList = data.duraklar[key].liste || [];

            // Eklenen araç tespiti
            const addedVehicle = newList.find(
              (n) => !prevList.some((p) => p.plate === n.plate)
            );
            if (addedVehicle) {
              lastModifiedVehicle = {
                durakKey: key,
                plate: addedVehicle.plate,
                action: "add",
              };
              break; // İlk değişikliği bul ve çık
            }
          }
        }

        const newVehicleCounts = {};
        // --- SESLİ BİLDİRİM (Sadece playSound true ise çalışır) ---
        if (options.playSound) {
          const priorityOrder = ["suvari", "merkez", "metro"]; // Öncelik sırası
          orderedDuraks.forEach((key) => {
            const aracSayisi = data.duraklar[key].liste
              ? data.duraklar[key].liste.filter((arac) => !arac.is_closed)
                  .length
              : 0;
            newVehicleCounts[key] = aracSayisi;
          });

          // Öncelik sırasına göre sesleri kuyruğa ekle
          priorityOrder.forEach((key) => {
            if (
              // Önceki araç sayısı tanımlıysa ve yeni sayı öncekinden farklıysa anonsu tetikle.
              // Bu, hem araç eklendiğinde hem de çıkarıldığında (0'a düşse bile) çalışır.
              previousVehicleCounts[key] !== undefined && // Önceki sayının tanımlı olduğundan emin ol
              previousVehicleCounts[key] !== newVehicleCounts[key] &&
              !stationMuteStatus[key] // Eğer ses kapalı değilse
            ) {
              const audioUrl = `https://raw.githubusercontent.com/tektekno/deneme_yeni/master/voices/${key}${newVehicleCounts[key]}.opus`;

              // Kuyrukta aynı durağa ait eski bir ses varsa onu kaldır.
              audioQueue = audioQueue.filter((url) => !url.includes(`/${key}`));
              audioQueue.push(audioUrl);
            } else if (
              previousVehicleCounts[key] === 0 &&
              newVehicleCounts[key] > 0
            ) {
              // Durak boş durumdan çıktığı için "boş kaldı" anonsunu ve zamanlayıcısını iptal et.
              clearTimeout(emptyStationTimers[key].timerId);
              emptyStationTimers[key].timerId = null;
              emptyStationTimers[key].lastAnnounced = 0;
              const emptyAudioUrl = `https://raw.githubusercontent.com/tektekno/deneme_yeni/master/voices/${key}0.opus`;
              audioQueue = audioQueue.filter((url) => url !== emptyAudioUrl);
            }
          });

          if (audioQueue.length > 0 && !isPlayingAudio) {
            playAudioFromQueue();
          }
        }

        // Bir sonraki kontrol için mevcut sayıları kaydet
        previousVehicleCounts = newVehicleCounts;
        // Bir sonraki render için tam veriyi kaydet
        previousData = JSON.parse(JSON.stringify(data));

        // Her bir durak için ayrı ayrı hizalama uzunluğunu belirle
        orderedDuraks.forEach((key) => {
          if (duraklar.hasOwnProperty(key)) {
            const durak = duraklar[key];
            const durakDiv = document.createElement("div");
            durakDiv.className = "durak";

            // Hız durumuna göre sınıf ekle
            if (key === fastest) {
              durakDiv.classList.add("hizli");
            } else if (key === middle) {
              durakDiv.classList.add("orta");
            } else if (key === slowest) {
              durakDiv.classList.add("yavas");
            }

            let htmlContent = "";

            const aracListesi = durak.liste || [];
            const activeVehicles = aracListesi.filter(
              (arac) => !arac.is_closed
            );
            const closedVehicles = aracListesi.filter((arac) => arac.is_closed);
            const aracSayisi = activeVehicles.length; // Sadece aktif araçları say

            // Başlık satırı
            const speakerIcon = stationMuteStatus[key] ? "🔇" : "🔊";
            htmlContent += `<span class="speaker-icon" data-durak-key="${key}">${speakerIcon}</span>`;

            htmlContent += `${durak_names[key]} (${aracSayisi})<br>`;

            // Ortalama kalkış satırı
            const formattedAverageDeparture = formatDuration(
              durak.ortalama_kalkis
            );
            htmlContent += `Ortalama Kalkış: ${formattedAverageDeparture}<br>`;

            // --- YENİ STİL MANTIĞI ---
            // Ekran yönüne göre duraklar container'ının stillerini ayarla
            if (aspectRatio < 1.1) {
              // Dikey mod için JS ile stil ata
              duraklarContainer.style.flexDirection = "column";
              duraklarContainer.style.alignItems = "center";
              duraklarContainer.style.gap = "2.4vh";
            } else {
              // Yatay moda geçildiğinde, dikey mod için JS ile eklenen stilleri sıfırla.
              // Bu, CSS media query'nin çalışmasını sağlar.
              duraklarContainer.style.flexDirection = "";
              duraklarContainer.style.alignItems = "";
              duraklarContainer.style.gap = "";
            }

            // --- AKIŞKAN FORMÜL İLE STİL HESAPLAMA ---

            // 1. Akışkan Font Boyutu: Ekran daraldıkça (aspectRatio küçüldükçe) font büyür.
            const fluidFontSize = `clamp(1.4vw, ${2 / aspectRatio}vw, 4.5vw)`;

            // 2. Akışkan Genişlik: Ekran daraldıkça genişlik artar.
            const fluidWidth = `clamp(30vw, ${50 / aspectRatio}vw, 85vw)`;

            // 3. Hesaplanan değerleri CSS değişkenleri olarak ata
            durakDiv.style.setProperty("--durak-font-size", fluidFontSize);
            durakDiv.style.setProperty("--durak-width", fluidWidth);

            // Bilgi tablosunun genişliğini de duraklarla aynı yapmak için
            document.documentElement.style.setProperty(
              "--durak-width",
              fluidWidth
            );

            // 4. Dikey/Yatay düzene göre flex-grow ve height ayarla
            if (aspectRatio < 1.1) {
              // Sadece Dikey Düzen için JS ayarı
              durakDiv.style.height = "auto";
              durakDiv.style.minHeight = "11vh"; // YENİ: Dikey modda minimum yükseklik sağlar.
              let flexGrowValue = 1;
              if (totalVehicles > 0) {
                flexGrowValue = 1 + (vehicleCounts[key] / totalVehicles) * 10;
              }
              durakDiv.style.flexGrow = flexGrowValue.toFixed(2);
            } else {
              // Yatay Düzen için JS ayarlarını sıfırla (CSS yönetecek)
              durakDiv.style.height = "";
              durakDiv.style.minHeight = "";
              durakDiv.style.maxHeight = "";
              durakDiv.style.flexGrow = "";
            }

            // Ayırıcı çizgi
            htmlContent += `<hr class="separator-line">`;

            // Araç listesi
            if (aracListesi.length > 0) {
              htmlContent += '<table class="vehicle-table"><tbody>';

              // Tüm araçlar için (aktif ve kapalı) hangi zaman birimlerinin gösterileceğini belirle
              const showDays = aracListesi.some(
                (a) => a.entry_duration >= 86400
              );
              const showHours = aracListesi.some(
                (a) => a.entry_duration >= 3600
              );
              const showMinutes = aracListesi.some(
                (a) => a.entry_duration >= 60
              );

              // 1. Kapalı araçları render et
              closedVehicles.forEach((arac) => {
                const rowStyle = 'style="color: #FF4C4C;"'; // Her zaman kırmızı
                const totalSeconds = arac.entry_duration;
                const days = Math.floor(totalSeconds / (24 * 60 * 60));
                const hours = Math.floor(
                  (totalSeconds % (24 * 60 * 60)) / (60 * 60)
                );
                const minutes = Math.floor((totalSeconds % (60 * 60)) / 60);
                const seconds = totalSeconds % 60;

                htmlContent += `<tr ${rowStyle}>`;
                htmlContent += `<td>K)</td>`; // Ön ek "K)"
                htmlContent += `<td>${arac.code}</td>`;
                htmlContent += `<td>${arac.plate}</td>`;

                // Süre gösterimi (aktif araçlarla aynı formatta)
                if (showDays && days > 0) {
                  htmlContent += `<td class="right-align">${padTimeDisplay(
                    days,
                    "gn"
                  )}</td>`;
                }
                if (showHours) {
                  htmlContent += `<td class="right-align">${padTimeDisplay(
                    hours,
                    "sa"
                  )}</td>`;
                  htmlContent += `<td class="right-align">${padTimeDisplay(
                    minutes,
                    "dk"
                  )}</td>`;
                  htmlContent += `<td class="right-align">${padTimeDisplay(
                    seconds,
                    "sn",
                    true
                  )}</td>`;
                } else if (showMinutes) {
                  htmlContent += `<td class="right-align">${padTimeDisplay(
                    minutes,
                    "dk"
                  )}</td>`;
                  htmlContent += `<td class="right-align">${padTimeDisplay(
                    seconds,
                    "sn",
                    true
                  )}</td>`;
                } else {
                  htmlContent += `<td class="right-align">${padTimeDisplay(
                    seconds,
                    "sn",
                    true
                  )}</td>`;
                }

                htmlContent += `</tr>`;
              });

              // Kapalı ve aktif araçlar arasında ayırıcı
              if (closedVehicles.length > 0 && activeVehicles.length > 0) {
                htmlContent += `<tr><td colspan="7"><hr class="sub-separator-line"></td></tr>`;
              }

              // 2. Aktif araçları render et
              activeVehicles.forEach((arac, index) => {
                const totalSeconds = arac.entry_duration;
                const days = Math.floor(totalSeconds / (24 * 60 * 60));
                const hours = Math.floor(
                  (totalSeconds % (24 * 60 * 60)) / (60 * 60)
                );
                const minutes = Math.floor((totalSeconds % (60 * 60)) / 60);
                const seconds = totalSeconds % 60;

                // Gizli mod aktifse kod ve plaka gösterimini değiştir
                const displayCode = currentHiddenMode ? "**" : arac.code;
                const displayPlate =
                  currentHiddenMode && arac.plate.includes("T")
                    ? arac.plate.substring(0, arac.plate.indexOf("T") + 1) +
                      "****"
                    : arac.plate;

                // Satıra özel ID ekle
                const rowId = `vehicle-${arac.plate.replace(/\s/g, "")}`;

                htmlContent += `<tr id="${rowId}">`;
                htmlContent += `<td>${index + 1})</td>`; // Numaralı ön ek
                htmlContent += `<td>${displayCode}</td>`;
                htmlContent += `<td>${displayPlate}</td>`;

                if (showDays && days > 0) {
                  htmlContent += `<td class="right-align">${padTimeDisplay(
                    days,
                    "gn"
                  )}</td>`;
                }
                if (showHours) {
                  htmlContent += `<td class="right-align">${padTimeDisplay(
                    hours,
                    "sa"
                  )}</td>`;
                  htmlContent += `<td class="right-align">${padTimeDisplay(
                    minutes,
                    "dk"
                  )}</td>`;
                  htmlContent += `<td class="right-align">${padTimeDisplay(
                    seconds,
                    "sn",
                    true
                  )}</td>`;
                } else if (showMinutes) {
                  htmlContent += `<td class="right-align">${padTimeDisplay(
                    minutes,
                    "dk"
                  )}</td>`;
                  htmlContent += `<td class="right-align">${padTimeDisplay(
                    seconds,
                    "sn",
                    true
                  )}</td>`;
                } else {
                  htmlContent += `<td class="right-align">${padTimeDisplay(
                    seconds,
                    "sn",
                    true
                  )}</td>`;
                }

                htmlContent += `</tr>`;
              });

              htmlContent += "</tbody></table>";
            } else {
              htmlContent += "Boş"; // Hiç araç yoksa
            }

            // YENİ: Sadece kapalı araç varsa, altına çizgi ve "Boş" yazısı ekle
            if (closedVehicles.length > 0 && activeVehicles.length === 0) {
              htmlContent += `<hr class="sub-separator-line">`;
              htmlContent += "Boş";
            }

            durakDiv.innerHTML = htmlContent;

            // YENİ: Mevcut durak div'ini bul ve yenisiyle değiştir, yoksa ekle.
            // Bu, innerHTML = "" kullanmaktan daha güvenlidir ve prompt'u korur.
            const existingDurakDiv = Array.from(
              duraklarContainer.children
            ).find((child) => child.querySelector(`[data-durak-key="${key}"]`));
            if (existingDurakDiv) {
              duraklarContainer.replaceChild(durakDiv, existingDurakDiv);
            } else {
              duraklarContainer.appendChild(durakDiv);
            }
          }
        });

        // --- EKLEME EFEKTİ UYGULAMA ---
        if (lastModifiedVehicle.action === "add" && lastModifiedVehicle.plate) {
          const plateId = lastModifiedVehicle.plate.replace(/\s/g, "");
          const rowElement = document.getElementById(`vehicle-${plateId}`);
          if (rowElement) {
            const cells = Array.from(rowElement.querySelectorAll("td"));
            const cellContents = cells.map((td) => td.innerHTML);
            rowElement.innerHTML = "<td>&nbsp;</td>".repeat(cells.length);
            animateCursorToRow(rowElement, () => {
              typewriterEffect(rowElement, cellContents);
            });
          }
          // Efekt uygulandıktan sonra sıfırla
          lastModifiedVehicle = { durakKey: null, plate: null, action: null };
        } else {
          // Eğer ekleme/silme efekti yoksa, imleci direkt hareket ettir.
          // renderData'nın DOM'u güncellemesi için küçük bir gecikme bırak.
          setTimeout(moveCursorToBottom, 100);
        }

        // YENİ: Veri her güncellendiğinde boş durak kontrolünü de tetikle.
        if (options.playSound) {
          manageEmptyStationAnnouncements();
        }
      }

      // --- DEBUG MODU ---
      // Test verilerini kullanmak için `true`, gerçek zamanlı Firebase verilerini kullanmak için `false` yapın.
      const DEBUG_MODE = false;

      // --- GİZLİ MOD AYARLARI ---

      // Zamanlayıcıyı aktif etmek için `true`, manuel kontrol için `false` yapın.
      const HIDDEN_MODE_TIMER = false;

      // Zamanlayıcı kapalıyken (HIDDEN_MODE_TIMER = false) gizli modu manuel açıp kapatmak için bu ayarı kullanın.
      const HIDDEN_MODE_MANUAL = false;

      // Zamanlayıcı ayarları (Sadece HIDDEN_MODE_TIMER = true ise geçerlidir)
      const HIDDEN_MODE_START_HOUR = 16;
      const HIDDEN_MODE_START_MINUTE = 0;
      const HIDDEN_MODE_END_HOUR = 5;
      const HIDDEN_MODE_END_MINUTE = 30;

      // --- GİZLİ MOD KONTROL MANTIĞI ---
      function isHiddenModeActive() {
        if (!HIDDEN_MODE_TIMER) {
          return HIDDEN_MODE_MANUAL;
        }

        const now = new Date();
        // UTC saatini alıp üzerine 3 saat ekleyerek Türkiye saatini buluyoruz.
        // Bu metod, tarayıcı saat dilimi ayarından bağımsız olarak UTC+3 saatini hesaplar.
        const turkeyHour = (now.getUTCHours() + 3) % 24;
        const turkeyMinute = now.getUTCMinutes();

        // Saat başlangıç saatinden sonra mı? (Başlangıç dakikası dahildir: >=)
        const isAfterStart =
          turkeyHour > HIDDEN_MODE_START_HOUR ||
          (turkeyHour === HIDDEN_MODE_START_HOUR &&
            turkeyMinute >= HIDDEN_MODE_START_MINUTE);

        // Saat bitiş saatinden önce mi? (Bitiş dakikası dahil değildir: <)
        // DÜZELTME: Gizli modun bitiş saatinde (örn. 05:30) kapanması için minute kontrolünü '<' yaptık.
        const isBeforeEnd =
          turkeyHour < HIDDEN_MODE_END_HOUR ||
          (turkeyHour === HIDDEN_MODE_END_HOUR &&
            turkeyMinute < HIDDEN_MODE_END_MINUTE);

        // Gece yarısını geçen bir aralık mı kontrolü (örn: 16:00 - 05:30)
        if (HIDDEN_MODE_START_HOUR > HIDDEN_MODE_END_HOUR) {
          // Ya başlangıçtan sonra (aynı gün) YA DA bitişten önce (ertesi gün)
          return isAfterStart || isBeforeEnd;
        }
        // Aynı gün içindeki aralık kontrolü (örn: 09:00 - 17:00)
        else {
          // Hem başlangıçtan sonra HEM DE bitişten önce olmalı
          return isAfterStart && isBeforeEnd;
        }
      }

      // Başlangıçta gizli mod durumunu hesapla ve sakla
      let currentHiddenMode = isHiddenModeActive();

      /**
       * Gizli mod durumunu 5 saniyede bir kontrol eder ve arayüzü günceller.
       */
      function checkHiddenModeAndRefresh() {
        const newHiddenMode = isHiddenModeActive();

        // Eğer gizli mod durumu değiştiyse VEYA DEBUG modunda isek (mock data'yı güncellemek için)
        if (newHiddenMode !== currentHiddenMode || DEBUG_MODE) {
          currentHiddenMode = newHiddenMode;
          // Yeni durumla birlikte arayüzü yeniden çiz
          if (latestData) {
            renderData(latestData);
          } else if (DEBUG_MODE) {
            // DEBUG modunda mockData'yı tekrar render et
            // MockData'nın güncel HiddenMode ile çalışmasını sağla
            renderData(mockData);
          }
        }
      }

      // Her 5 saniyede bir gizli mod durumunu kontrol et
      setInterval(checkHiddenModeAndRefresh, 5000);

      // YENİ: Her 10 saniyede bir boş durakları kontrol et
      setInterval(manageEmptyStationAnnouncements, 10000);

      // --- YENİ: Firebase Dinleyici Fonksiyonları (Global Kapsam) ---
      // Bu fonksiyonları global kapsama taşıyarak, DOM yeniden oluşturulduğunda bile
      // referanslarının kaybolmamasını sağlıyoruz.
      const firebaseListener = (snapshot) => {
        const data = snapshot.val();
        if (!data || !data.duraklar) {
          console.error("Veri alınamadı veya 'duraklar' anahtarı bulunamadı.");
          if (duraklarContainer) {
            duraklarContainer.innerHTML =
              '<p style="color:red; text-align:center;">Veri alınamadı. Lütfen Python betiğinin çalıştığından emin olun.</p>';
          }
          return;
        }

        if (previousData) {
          const removedVehicleInfo = orderedDuraks
            .map((key) => {
              const prevList = previousData.duraklar[key].liste || [];
              const newList = data.duraklar[key].liste || [];
              const removed = prevList.find(
                (p) => !newList.some((n) => n.plate === p.plate)
              );
              return removed ? { durakKey: key, ...removed } : null;
            })
            .find(Boolean);

          if (removedVehicleInfo) {
            const plateId = removedVehicleInfo.plate.replace(/\s/g, "");
            const rowElement = document.getElementById(`vehicle-${plateId}`);
            if (rowElement) {
              animateCursorToRow(rowElement, () => {
                deleteEffect(rowElement, () => renderData(data));
              });
              return;
            }
          }
        }
        renderData(data);
      };

      const firebaseErrorCallback = (error) => {
        console.error("Veri okuma hatası: ", error);
        if (duraklarContainer) {
          duraklarContainer.innerHTML =
            '<p style="color:red; text-align:center;">Veri okuma hatası oluştu. Konsolu kontrol edin.</p>';
        }
      };

      if (DEBUG_MODE) {
        // --- DEBUG MODU İÇİN KONTROL VE VERİ YAPISI ---

        // 1. Butonları ve kontrol panelini görünür yap
        const debugControls = document.getElementById("debug-controls");
        const STORAGE_KEY = "debugVehicleState";
        debugControls.style.display = "flex";
        document.getElementById("debug-warning").style.display = "block";

        // 2. Tüm olası araçları içeren bir havuz oluştur
        const allVehicles = [
          { code: "21", plate: "35T7575" },
          { code: "22", plate: "35T5702" },
          { code: "23", plate: "35T6619" },
          { code: "24", plate: "35T7734" },
          { code: "25", plate: "35T5595" },
          { code: "26", plate: "35T6913" },
          { code: "27", plate: "35T6581" },
          { code: "28", plate: "35T6272" },
          { code: "29", plate: "35T5023" },
          { code: "30", plate: "35T7274" },
          { code: "32", plate: "35T6383" },
          { code: "33", plate: "35T7623" },
          { code: "34", plate: "35T6975" },
          { code: "35", plate: "35T5601" },
          { code: "36", plate: "35T7812" },
          { code: "37", plate: "35T5071" },
        ];

        // 3. localStorage'dan kayıtlı durumu yükle veya başlangıç verisini oluştur
        const savedState = localStorage.getItem(STORAGE_KEY);
        const initialDuraklarState = savedState
          ? JSON.parse(savedState)
          : {
              merkez: { liste: [], ortalama_kalkis: 6200 },
              metro: { liste: [], ortalama_kalkis: 950 },
              suvari: {
                liste: [{ code: "27", plate: "35T6581", entry_duration: 40 }],
                ortalama_kalkis: 40,
              },
            };

        const mockData = {
          son_guncelleme: "18.09.2023 | 10:00:00 (Test Verisi)",
          duraklar: initialDuraklarState,
        };

        // 4. Butonlara olay dinleyicileri ekle
        document
          .getElementById("add-merkez")
          .addEventListener("click", () => addVehicle("merkez"));
        document
          .getElementById("add-closed-merkez")
          .addEventListener("click", () => addVehicle("merkez", true));
        document
          .getElementById("remove-merkez")
          .addEventListener("click", () => removeVehicle("merkez"));

        document
          .getElementById("add-metro")
          .addEventListener("click", () => addVehicle("metro"));
        document
          .getElementById("add-closed-metro")
          .addEventListener("click", () => addVehicle("metro", true));
        document
          .getElementById("remove-metro")
          .addEventListener("click", () => removeVehicle("metro"));

        document
          .getElementById("add-suvari")
          .addEventListener("click", () => addVehicle("suvari"));
        document
          .getElementById("add-closed-suvari")
          .addEventListener("click", () => addVehicle("suvari", true));
        document
          .getElementById("remove-suvari")
          .addEventListener("click", () => removeVehicle("suvari"));

        function saveState() {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(mockData.duraklar));
        }

        function getTotalVehicleCount() {
          return (
            mockData.duraklar.merkez.liste.length +
            mockData.duraklar.metro.liste.length +
            mockData.duraklar.suvari.liste.length
          );
        }

        function addVehicle(durakKey, isClosed = false) {
          if (mockData.duraklar[durakKey].liste.length >= 10) {
            // Not: alert() yerine daha iyi bir yöntem kullanılmalıdır, ancak debug için kabul edilebilir.
            console.error("Bu durağa daha fazla araç eklenemez (maksimum 10)!");
            return;
          }

          if (getTotalVehicleCount() >= 16) {
            console.error("Toplam araç sayısı 16'yı geçemez!");
            return;
          }

          // Henüz duraklarda olmayan bir araç bul
          const assignedPlates = [
            ...mockData.duraklar.merkez.liste,
            ...mockData.duraklar.metro.liste,
            ...mockData.duraklar.suvari.liste,
          ].map((v) => v.plate);
          const availableVehicle = allVehicles.find(
            (v) => !assignedPlates.includes(v.plate)
          );

          if (availableVehicle) {
            const newVehicle = {
              ...availableVehicle,
              entry_duration: Math.floor(Math.random() * 10000),
              is_closed: isClosed, // Kapalı olup olmadığını ayarla
            };
            mockData.duraklar[durakKey].liste.push(newVehicle);
            saveState(); // Durumu localStorage'a kaydet
            renderData(mockData); // Arayüzü güncelle
          }
        }

        function removeVehicle(durakKey) {
          if (mockData.duraklar[durakKey].liste.length > 0) {
            // 1. Silinecek aracı belirle
            const vehicleToRemove = mockData.duraklar[durakKey].liste.pop(); // .pop() hem siler hem de silineni döndürür.

            // 2. Animasyon için satırı DOM'dan bul ve klonla (veri silindikten SONRA).
            const plateId = vehicleToRemove.plate.replace(/\s/g, "");
            const rowElement = document.getElementById(`vehicle-${plateId}`);

            // 3. Arayüzü güncel veriyle (araç silinmiş haliyle) yeniden çiz.
            renderData(mockData);

            // 4. Klonlanmış satır varsa (yani DOM'da bulunduysa) animasyonu başlat.
            if (rowElement) {
              const clonedRow = rowElement.cloneNode(true);
              const durakDiv = document.querySelector(
                `[data-durak-key="${durakKey}"]`
              )?.parentElement;
              const tableBody = durakDiv?.querySelector(".vehicle-table tbody");

              if (tableBody) {
                // Klonu animasyon için geçici olarak ekle
                tableBody.appendChild(clonedRow);
                // Silme animasyonunu başlat ve bittiğinde klonu kaldır
                animateCursorToRow(clonedRow, () => {
                  deleteEffect(clonedRow, () => {
                    clonedRow.remove();
                  });
                });
              }
            }

            saveState(); // State'i kaydet
          } else {
            console.error(`${durakKey} durağında silinecek araç yok.`);
          }
        }

        // 5. Sayfa ilk yüklendiğinde mock veriyi render et
        renderData(mockData);
      } else {
        // Gerçek zamanlı dinleyiciyi başlat
        ref.on("value", firebaseListener, firebaseErrorCallback);

        // Sayfa görünürlüğü değiştiğinde dinleyiciyi yönet
        document.addEventListener("visibilitychange", () => {
          if (document.hidden) {
            // Sayfa arka plana alındı: dinleyiciyi kapat ve sesleri temizle
            ref.off("value", firebaseListener);
            audioQueue = [];
            console.log("Uygulama askıya alındı, veri akışı durduruldu.");
          } else {
            // Sayfa ön plana geldi: veriyi sessizce çek, sonra dinleyiciyi yeniden başlat
            console.log("Uygulama devam ediyor, veriler yenileniyor...");
            // Önceki araç sayılarını, ses çalmadan güncel durumla doldur.
            // Bu, bir sonraki gerçek güncellemede doğru karşılaştırma yapılmasını sağlar.
            ref.once("value", (snapshot) => {
              const data = snapshot.val();
              if (data && data.duraklar) {
                orderedDuraks.forEach((key) => {
                  previousVehicleCounts[key] = data.duraklar[key].liste
                    ? data.duraklar[key].liste.filter((arac) => !arac.is_closed)
                        .length
                    : 0;
                });
                renderData(data, { playSound: false });
              }
            });
            ref.on("value", firebaseListener, firebaseErrorCallback);
          }
        });
      }

      // Sayfa yüklendiğinde ve pencere yeniden boyutlandırıldığında tüm ayarları yap
      window.addEventListener("load", () => {
        // --- Matrix Arka Plan Animasyonu ---
        const canvas = document.getElementById("matrix-canvas");
        const ctx = canvas.getContext("2d");

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const katakana =
          "アァカサタナハマヤャラワガザダバパイィキシチニヒミリヰギジヂビピウゥクスツヌフムユュルグズブヅプエェケセテネヘメレヱゲゼデベペオォコソトノホモヨョロヲゴゾドボポヴッン";
        const latin = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        const nums = "0123456789";
        const alphabet = katakana + latin + nums;

        const fontSize = 16;
        const columns = canvas.width / fontSize;
        const rainDrops = [];

        for (let x = 0; x < columns; x++) {
          // YENİ: Damlaların rastgele dikey konumlarda başlamasını sağla
          rainDrops[x] = Math.floor(Math.random() * (canvas.height / fontSize));
        }

        const drawMatrix = () => {
          ctx.fillStyle = "rgba(0, 0, 0, 0.05)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          ctx.fillStyle = "#00ff41"; // Matrix yeşili
          ctx.font = fontSize + "px monospace";

          for (let i = 0; i < rainDrops.length; i++) {
            const text = alphabet.charAt(
              Math.floor(Math.random() * alphabet.length)
            );
            ctx.fillText(text, i * fontSize, rainDrops[i] * fontSize);

            if (
              rainDrops[i] * fontSize > canvas.height &&
              Math.random() > 0.975
            ) {
              rainDrops[i] = 0;
            }
            rainDrops[i]++;
          }
        };

        const matrixInterval = setInterval(drawMatrix, 33);

        // Giriş ekranı için olay dinleyicisi
        const introOverlay = document.getElementById("intro-overlay");
        const introButton = document.querySelector(".intro-button");

        introButton.addEventListener(
          "click",
          function () {
            // Ses motorunu "uyandır"
            function startApp() {
              if (!firstInteraction) {
                firstInteraction = true;
                // AudioContext'i oluştur veya devam ettir
                audioContext = new (window.AudioContext ||
                  window.webkitAudioContext)({ latencyHint: "playback" });
                audioContext.resume(); // Kullanıcı etkileşiminden sonra başlat

                // Diğer sesleri arka planda yükle
                preloadAudioFiles();
              }
              // Global imleci göster
              globalCursor.style.display = "block";
              // Terminal içeriğini göster
              terminalContent.style.display = "flex";
              // Giriş ekranını yavaşça gizle
              introOverlay.style.opacity = "0";
              // Animasyon bittikten sonra DOM'dan kaldır
              setTimeout(() => {
                if (introOverlay) {
                  clearInterval(matrixInterval); // Animasyonu durdur
                  introOverlay.remove();
                }
              }, 500);

              // Eğer boot animasyonu aktif değilse, imleci direkt aşağı taşı.
              // Aktifse, animasyon bittiğinde veri zaten çizileceği için imleç de konumlanacak.
              if (!ENABLE_BOOT_SEQUENCE) {
                moveCursorToBottom();
              }
            }

            if (ENABLE_BOOT_SEQUENCE) {
              // Önce arayüzü hazırla, sonra animasyonu başlat.
              startApp();
              // Animasyon bittiğinde, Firebase'den gelen ilk verinin çizilmesini bekle.
              // Firebase listener zaten veriyi alınca renderData'yı çağıracak.
              runBootSequence(() => {
                // Animasyon bittiğinde ana container'ı temizle ki asıl içerik gelsin.
                document.getElementById("main-container").innerHTML = `
                  <div class="updatetime-container">
                    <div id="loader" class="loader"></div>
                    <table id="info-table" style="display: none">
                      <tbody>
                        <tr><td class="info-key">Son Güncelleme:</td><td id="info-updatetime" class="info-value"></td></tr>
                        <tr><td class="info-key">Araç Durumları:</td><td id="info-gps" class="info-value"></td></tr>
                        <tr><td class="info-key">Duyuru:</td><td id="info-closed-vehicle" class="info-value"></td></tr>
                        <tr><td class="info-key">Hava Durumu:</td><td id="info-weather" class="info-value"></td></tr>
                      </tbody>
                    </table>
                  </div>
                  <div id="traffic-banner-container" style="display: none;"><div id="traffic-banner-content"></div></div>
                  <div id="duraklar-container" class="container"></div>
                `;
                // YENİ: DOM elementleri yeniden oluşturulduğu için referansları güncelle.
                mainContainer = document.getElementById("main-container");
                duraklarContainer =
                  document.getElementById("duraklar-container");
                loaderElement = document.getElementById("loader");
                infoTable = document.getElementById("info-table");
                infoUpdateTime = document.getElementById("info-updatetime");
                infoGps = document.getElementById("info-gps");
                infoClosedVehicle = document.getElementById(
                  "info-closed-vehicle"
                );
                infoWeather = document.getElementById("info-weather");

                // Eğer veri çoktan geldiyse (animasyon sırasında), hemen çiz.
                if (latestData) {
                  renderData(latestData, { playSound: false });
                }
              });
            } else {
              // Animasyon kapalıysa, uygulamayı direkt başlat.
              startApp();
            }
          },
          { once: true }
        ); // Olay dinleyicisi sadece bir kez çalışsın

        // Ses kontrol ikonları için olay dinleyicisi
        document.body.addEventListener("click", function (e) {
          if (e.target && e.target.classList.contains("speaker-icon")) {
            const durakKey = e.target.getAttribute("data-durak-key");
            if (durakKey && stationMuteStatus.hasOwnProperty(durakKey)) {
              // Ses durumunu tersine çevir
              stationMuteStatus[durakKey] = !stationMuteStatus[durakKey];
              // İkonu güncelle
              e.target.textContent = stationMuteStatus[durakKey] ? "🔇" : "🔊";
            }
          }
        });

        // YENİ: Tam ekran butonu için olay dinleyicisi
        const fullscreenBtn = document.getElementById("fullscreen-btn");
        fullscreenBtn.addEventListener("click", () => {
          if (!document.fullscreenElement) {
            // Tam ekranda değilse, tam ekrana geç
            document.documentElement.requestFullscreen().catch((err) => {
              alert(
                `Tam ekran moduna geçilemedi: ${err.message} (${err.name})`
              );
            });
          } else {
            // Tam ekrandaysa, çık
            if (document.exitFullscreen) {
              document.exitFullscreen();
            }
          }
        });
      });

      // Pencere boyutu değiştiğinde viewport bilgisini güncelle
      window.addEventListener("resize", () => {
        // YENİ: Sayfayı yeniden yüklemek yerine arayüzü yeniden çiz.
        // Bu, tam ekran veya döndürme sırasında başlangıç ekranına dönmeyi engeller.
        // Sadece giriş yapıldıysa ve veri varsa yeniden çiz.
        if (!firstInteraction || !latestData) return;

        // Efektlerin ve animasyonların yeniden tetiklenmesini önlemek için
        // önceki veri durumunu ve son işlem bilgisini sıfırla.
        previousData = null; // Bu, renderData içindeki değişiklik tespitini sıfırlar.
        lastModifiedVehicle = { durakKey: null, plate: null, action: null }; // Animasyonları sıfırlar.

        // Arayüzü mevcut veriyle yeniden çiz.
        renderData(latestData);
      });

      // YENİ: Kayan trafik bandını oluşturan fonksiyon
      function renderTrafficBanner(data) {
        if (!data || !data.trafik_durumu) return;

        const bannerContainer = document.getElementById(
          "traffic-banner-container"
        );
        const bannerContent = document.getElementById("traffic-banner-content");

        bannerContent.innerHTML = getTrafficStatusVertical(data.trafik_durumu);
        bannerContainer.style.display = "block";
      }
    </script>
  </body>
</html>
